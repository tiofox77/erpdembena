<?php

namespace App\Livewire\Reports;

use Livewire\Component;
use App\Models\MaintenanceEquipment as Equipment;
use App\Models\MaintenanceArea as Area;
use App\Models\MaintenanceLine as Line;
use App\Models\MaintenanceTask;
use App\Models\MaintenancePlan;
use App\Models\MaintenanceTaskLog as TaskLog;
use App\Models\MaintenanceCorrective as DowntimeRecord;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Schema;

class DowntimeImpact extends Component
{
    // Filters
    public $dateRange = 'month';
    public $startDate;
    public $endDate;
    public $selectedArea = 'all';
    public $selectedLine = 'all';
    public $downtimeType = 'all';
    public $sortField = 'duration';
    public $sortDirection = 'desc';

    // Data properties
    public $areas = [];
    public $lines = [];
    public $downtimeRecords = [];
    public $totalDowntime = 0;
    public $productionLoss = 0;
    public $financialImpact = 0;
    public $availabilityRate = 0;
    public $mostCriticalEquipment = '';
    public $mostCriticalDowntime = 0;
    public $recommendations = [];

    // Chart data
    public $downtimeByEquipmentData = [];
    public $downtimeTypesData = [];
    public $downtimeTrendData = [];
    public $financialImpactData = [];

    public function mount()
    {
        try {
            Log::info('DowntimeImpact: Mounting component');
            
            // Load areas and lines for filters
            $this->areas = Area::pluck('name', 'id')->toArray();
            $this->lines = Line::pluck('name', 'id')->toArray();
            
            Log::info('DowntimeImpact: Loaded areas and lines', [
                'areasCount' => count($this->areas),
                'linesCount' => count($this->lines)
            ]);

            // Set default date range
            $this->setDateRange($this->dateRange);
            
            Log::info('DowntimeImpact: Date range set', [
                'dateRange' => $this->dateRange,
                'startDate' => $this->startDate,
                'endDate' => $this->endDate
            ]);

            // Ensure we have valid dates to prevent errors
            if (empty($this->startDate) || empty($this->endDate)) {
                $now = Carbon::now();
                $this->startDate = $now->copy()->startOfMonth()->format('Y-m-d');
                $this->endDate = $now->copy()->endOfMonth()->format('Y-m-d');
            }

            // Load initial data
            $this->loadChartData();
            
            Log::info('DowntimeImpact: Initial data loaded successfully');
        } catch (\Exception $e) {
            Log::error('Error in DowntimeImpact mount method', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Initialize with default values to prevent view errors
            $this->setDefaultChartData();
        }
    }

    public function updatedDateRange()
    {
        $this->setDateRange($this->dateRange);
        $this->loadChartData();
    }

    public function updatedStartDate()
    {
        $this->loadChartData();
    }

    public function updatedEndDate()
    {
        $this->loadChartData();
    }

    public function updatedSelectedArea()
    {
        $this->loadChartData();
    }

    public function updatedSelectedLine()
    {
        $this->loadChartData();
    }

    public function updatedDowntimeType()
    {
        $this->loadChartData();
    }

    public function setDateRange($range)
    {
        $now = Carbon::now();

        switch ($range) {
            case 'week':
                $this->startDate = $now->startOfWeek()->format('Y-m-d');
                $this->endDate = $now->endOfWeek()->format('Y-m-d');
                break;
            case 'month':
                $this->startDate = $now->startOfMonth()->format('Y-m-d');
                $this->endDate = $now->endOfMonth()->format('Y-m-d');
                break;
            case 'quarter':
                $this->startDate = $now->startOfQuarter()->format('Y-m-d');
                $this->endDate = $now->endOfQuarter()->format('Y-m-d');
                break;
            case 'year':
                $this->startDate = $now->startOfYear()->format('Y-m-d');
                $this->endDate = $now->endOfYear()->format('Y-m-d');
                break;
            case 'custom':
                // Keep the existing custom dates or set defaults if empty
                if (empty($this->startDate)) {
                    $this->startDate = $now->subDays(30)->format('Y-m-d');
                }
                if (empty($this->endDate)) {
                    $this->endDate = $now->format('Y-m-d');
                }
                break;
        }
    }

    public function sortBy($field)
    {
        if ($this->sortField === $field) {
            $this->sortDirection = $this->sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
            $this->sortField = $field;
            $this->sortDirection = 'asc';
        }

        // Re-sort the downtime records
        $this->downtimeRecords = collect($this->downtimeRecords)
            ->sortBy([$field => $this->sortDirection === 'asc' ? 'asc' : 'desc'])
            ->values()
            ->toArray();
    }

    public function loadChartData()
    {
        try {
            Log::info('DowntimeImpact: Starting to load chart data', [
                'dateRange' => $this->dateRange,
                'startDate' => $this->startDate,
                'endDate' => $this->endDate,
                'area' => $this->selectedArea,
                'line' => $this->selectedLine,
                'downtimeType' => $this->downtimeType
            ]);
            
            // Get equipment IDs based on filters
            $equipmentQuery = Equipment::query();

            if ($this->selectedArea !== 'all') {
                $equipmentQuery->where('area_id', $this->selectedArea);
            }

            if ($this->selectedLine !== 'all') {
                $equipmentQuery->where('line_id', $this->selectedLine);
            }

            $equipmentIds = $equipmentQuery->pluck('id')->toArray();
            
            Log::info('DowntimeImpact: Retrieved equipment IDs', [
                'count' => count($equipmentIds),
                'ids' => $equipmentIds
            ]);
            
            // Se não houver equipamentos, não há como ter dados de downtime
            if (empty($equipmentIds)) {
                Log::warning('DowntimeImpact: No equipment IDs found for the selected filters');
                $this->setDefaultChartData();
                return;
            }

            // Generate chart data
            $this->getDowntimeRecords($equipmentIds, $this->startDate, $this->endDate);
            Log::info('DowntimeImpact: Retrieved downtime records', [
                'count' => count($this->downtimeRecords)
            ]);
            
            $this->getDowntimeByEquipmentData($equipmentIds, $this->startDate, $this->endDate);
            $this->getDowntimeTypesData($equipmentIds, $this->startDate, $this->endDate);
            $this->getDowntimeTrendData($equipmentIds, $this->startDate, $this->endDate);
            $this->getFinancialImpactData($equipmentIds, $this->startDate, $this->endDate);
            $this->generateRecommendations();
            
            Log::info('DowntimeImpact: All chart data loaded successfully');

        } catch (\Exception $e) {
            Log::error('Error loading downtime impact data', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            $this->setDefaultChartData();
        }
    }

    protected function getDowntimeRecords($equipmentIds, $startDate, $endDate)
    {
        try {
            // Log início da consulta
            Log::info('DowntimeImpact: Starting downtime records query', [
                'equipmentIdsCount' => count($equipmentIds),
                'startDate' => $startDate,
                'endDate' => $endDate,
                'downtimeType' => $this->downtimeType
            ]);
            
            // Query downtime records - verificar se tabela é maintenance_correctives
            $query = DowntimeRecord::whereIn('equipment_id', $equipmentIds);
            
            // Verificar os campos de data na tabela
            if (Schema::hasColumn('maintenance_correctives', 'start_date')) {
                $query->whereBetween('start_date', [$startDate, $endDate]);
                Log::info('DowntimeImpact: Using start_date for date filtering');
            } else if (Schema::hasColumn('maintenance_correctives', 'date')) {
                $query->whereBetween('date', [$startDate, $endDate]);
                Log::info('DowntimeImpact: Using date for date filtering');
            } else if (Schema::hasColumn('maintenance_correctives', 'created_at')) {
                $query->whereBetween('created_at', [$startDate . ' 00:00:00', $endDate . ' 23:59:59']);
                Log::info('DowntimeImpact: Using created_at for date filtering');
            } else {
                Log::warning('DowntimeImpact: No suitable date column found for filtering');
            }

            // Aplicar filtro de tipo de downtime
            if ($this->downtimeType !== 'all') {
                // Determinar o valor correto para o filtro de tipo
                $typeValue = $this->downtimeType;
                if (strtolower($this->downtimeType) === 'planned') {
                    $typeValue = 'Planned';
                } else if (strtolower($this->downtimeType) === 'unplanned') {
                    $typeValue = 'Unplanned';
                } else if (strtolower($this->downtimeType) === 'operational') {
                    $typeValue = 'Operational';
                }
                
                // Verificar se o campo 'type' existe
                if (Schema::hasColumn('maintenance_correctives', 'type')) {
                    $query->where('type', $typeValue);
                    Log::info('DowntimeImpact: Applied type filter', ['typeValue' => $typeValue]);
                } else {
                    Log::warning('DowntimeImpact: Type column not found in maintenance_correctives table');
                }
            }

            // Log query SQL para depuração
            $querySql = $query->toSql();
            $queryBindings = $query->getBindings();
            Log::info('DowntimeImpact: Query SQL', [
                'sql' => $querySql,
                'bindings' => $queryBindings
            ]);

            // Executar a consulta com eager loading
            $records = $query->with(['equipment', 'equipment.area', 'equipment.line'])->get();
            
            Log::info('DowntimeImpact: Query executed', ['recordCount' => $records->count()]);

            // Process records for display
            $this->downtimeRecords = $records->map(function($record) {
                // Determinar o campo de data correto
                $startDate = null;
                if (isset($record->start_date)) {
                    $startDate = $record->start_date;
                } else if (isset($record->date)) {
                    $startDate = $record->date;
                } else if (isset($record->created_at)) {
                    $startDate = $record->created_at;
                }
                
                // Determinar o campo de duração correto
                $duration = 0;
                if (isset($record->duration_hours)) {
                    $duration = $record->duration_hours;
                } else if (isset($record->downtime)) {
                    $duration = $record->downtime;
                } else if (isset($record->hours)) {
                    $duration = $record->hours;
                }
                
                // Verificar campos relacionados ao equipamento para evitar erros
                $equipmentName = 'Unknown';
                $serialNumber = '';
                $areaName = 'Unknown';
                $lineName = 'Unknown';
                
                if ($record->equipment) {
                    $equipmentName = $record->equipment->name ?? 'Unknown';
                    $serialNumber = $record->equipment->serial_number ?? '';
                    
                    if ($record->equipment->area) {
                        $areaName = $record->equipment->area->name ?? 'Unknown';
                    }
                    
                    if ($record->equipment->line) {
                        $lineName = $record->equipment->line->name ?? 'Unknown';
                    }
                }
                
                return [
                    'id' => $record->id,
                    'start_date' => $startDate ? Carbon::parse($startDate)->format('Y-m-d H:i') : 'N/A',
                    'equipment' => $equipmentName,
                    'serial_number' => $serialNumber,
                    'area' => $areaName,
                    'line' => $lineName,
                    'type' => $record->type ?? 'Unknown',
                    'reason' => $record->reason ?? 'N/A',
                    'duration' => $duration,
                    'production_loss' => $record->production_loss_units ?? 0,
                    'financial_impact' => $record->financial_impact ?? 0
                ];
            })->sortByDesc('duration')->values()->toArray();

            // Calculate summary metrics safely
            $this->totalDowntime = 0;
            $this->productionLoss = 0;
            $this->financialImpact = 0;
            
            // Verificar campos antes de calcular somas
            if (Schema::hasColumn('maintenance_correctives', 'duration_hours')) {
                $this->totalDowntime = $records->sum('duration_hours');
            } else if (Schema::hasColumn('maintenance_correctives', 'downtime')) {
                $this->totalDowntime = $records->sum('downtime');
            } else if (Schema::hasColumn('maintenance_correctives', 'hours')) {
                $this->totalDowntime = $records->sum('hours');
            }
            
            if (Schema::hasColumn('maintenance_correctives', 'production_loss_units')) {
                $this->productionLoss = $records->sum('production_loss_units');
            }
            
            if (Schema::hasColumn('maintenance_correctives', 'financial_impact')) {
                $this->financialImpact = $records->sum('financial_impact');
            }

            // Calculate availability rate
            $totalPeriodHours = Carbon::parse($startDate)->diffInHours(Carbon::parse($endDate)) * count($equipmentIds);
            $this->availabilityRate = $totalPeriodHours > 0
                ? round(100 - (($this->totalDowntime / $totalPeriodHours) * 100), 1)
                : 100;

            // Find most critical equipment
            if ($records->isNotEmpty()) {
                $criticalEquipment = $records->groupBy('equipment_id')
                    ->map(function($group) {
                        $duration = 0;
                        if (isset($group->first()->duration_hours)) {
                            $duration = $group->sum('duration_hours');
                        } else if (isset($group->first()->downtime)) {
                            $duration = $group->sum('downtime');
                        } else if (isset($group->first()->hours)) {
                            $duration = $group->sum('hours');
                        }
                        
                        return [
                            'equipment_id' => $group->first()->equipment_id,
                            'equipment_name' => $group->first()->equipment->name ?? 'Unknown Equipment',
                            'total_downtime' => $duration
                        ];
                    })
                    ->sortByDesc('total_downtime')
                    ->first();

                $this->mostCriticalEquipment = $criticalEquipment['equipment_name'] ?? 'None';
                $this->mostCriticalDowntime = $criticalEquipment['total_downtime'] ?? 0;
            } else {
                $this->mostCriticalEquipment = 'None';
                $this->mostCriticalDowntime = 0;
            }
            
            Log::info('DowntimeImpact: Downtime records processed', [
                'recordCount' => count($this->downtimeRecords),
                'totalDowntime' => $this->totalDowntime,
                'availabilityRate' => $this->availabilityRate,
                'mostCriticalEquipment' => $this->mostCriticalEquipment
            ]);
        } catch (\Exception $e) {
            Log::error('Error in getDowntimeRecords', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Inicializar com valores vazios para evitar erros na view
            $this->downtimeRecords = [];
            $this->totalDowntime = 0;
            $this->productionLoss = 0;
            $this->financialImpact = 0;
            $this->availabilityRate = 100;
            $this->mostCriticalEquipment = 'None';
            $this->mostCriticalDowntime = 0;
        }
    }

    protected function getDowntimeByEquipmentData($equipmentIds, $startDate, $endDate)
    {
        try {
            Log::info('DowntimeImpact: Iniciando getDowntimeByEquipmentData');
            
            // Verificar quais campos usar para filtragem e cálculos
            $dateField = 'created_at';
            $durationField = '';
            
            // Determinar o campo de data a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'start_date')) {
                $dateField = 'start_date';
            } else if (Schema::hasColumn('maintenance_correctives', 'date')) {
                $dateField = 'date';
            }
            
            // Determinar o campo de duração a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'duration_hours')) {
                $durationField = 'duration_hours';
            } else if (Schema::hasColumn('maintenance_correctives', 'downtime')) {
                $durationField = 'downtime';
            } else if (Schema::hasColumn('maintenance_correctives', 'hours')) {
                $durationField = 'hours';
            } else {
                // Se não encontrar campo de duração, usar contagem de registros
                $durationField = 'id';
                Log::warning('DowntimeImpact: Nenhum campo de duração encontrado, usando contagem de registros');
            }
            
            // Log dos campos selecionados
            Log::info('DowntimeImpact: Campos selecionados para consulta', [
                'dateField' => $dateField,
                'durationField' => $durationField
            ]);
            
            // Preparar a consulta base
            $query = DowntimeRecord::whereIn('equipment_id', $equipmentIds);
            
            // Aplicar filtro de data
            if ($dateField === 'created_at') {
                $query->whereBetween($dateField, [$startDate . ' 00:00:00', $endDate . ' 23:59:59']);
            } else {
                $query->whereBetween($dateField, [$startDate, $endDate]);
            }

            // Aplicar filtro de tipo, se fornecido
            if ($this->downtimeType !== 'all' && Schema::hasColumn('maintenance_correctives', 'type')) {
                $typeValue = $this->downtimeType;
                if (strtolower($this->downtimeType) === 'planned') {
                    $typeValue = 'Planned';
                } else if (strtolower($this->downtimeType) === 'unplanned') {
                    $typeValue = 'Unplanned';
                } else if (strtolower($this->downtimeType) === 'operational') {
                    $typeValue = 'Operational';
                }
                
                $query->where('type', $typeValue);
            }
            
            // Preparar o SQL para agrupar por equipamento
            if ($durationField === 'id') {
                // Se não encontrou campo de duração, usa contagem
                $query->select('equipment_id', DB::raw('COUNT(id) as total_downtime'));
            } else {
                // Se encontrou campo de duração, usa soma
                $query->select('equipment_id', DB::raw('SUM(' . $durationField . ') as total_downtime'));
            }
            
            // Log query SQL para depuração
            $querySql = $query->toSql();
            $queryBindings = $query->getBindings();
            Log::info('DowntimeImpact: Query SQL para dados de equipamento', [
                'sql' => $querySql,
                'bindings' => $queryBindings
            ]);
            
            // Executar a consulta agrupada
            $topEquipment = $query->groupBy('equipment_id')
                ->orderByDesc('total_downtime')
                ->limit(10)
                ->with('equipment')
                ->get();
            
            Log::info('DowntimeImpact: Consulta de equipamentos executada', [
                'count' => count($topEquipment)
            ]);

            // Extrair labels e dados
            $labels = $topEquipment->map(function($item) {
                return $item->equipment->name ?? 'Unknown Equipment';
            })->toArray();

            $data = $topEquipment->pluck('total_downtime')->toArray();
            
            Log::info('DowntimeImpact: Dados extraídos para gráfico', [
                'labelsCount' => count($labels),
                'dataCount' => count($data)
            ]);

            // Montar dados para o gráfico
            $this->downtimeByEquipmentData = [
                'labels' => $labels,
                'datasets' => [
                    [
                        'label' => 'Downtime Hours',
                        'data' => $data,
                        'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                        'borderColor' => 'rgba(54, 162, 235, 1)',
                        'borderWidth' => 1
                    ]
                ]
            ];

            // Se não houver dados, usar valores padrão
            if (empty($labels)) {
                Log::info('DowntimeImpact: Nenhum dado encontrado, usando valores padrão');
                $this->downtimeByEquipmentData = [
                    'labels' => ['No data available'],
                    'datasets' => [
                        [
                            'label' => 'Downtime Hours',
                            'data' => [0],
                            'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                            'borderColor' => 'rgba(54, 162, 235, 1)',
                            'borderWidth' => 1
                        ]
                    ]
                ];
            }
            
            Log::info('DowntimeImpact: getDowntimeByEquipmentData concluído com sucesso');
        } catch (\Exception $e) {
            Log::error('Erro em getDowntimeByEquipmentData', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Em caso de erro, usar valores padrão
            $this->downtimeByEquipmentData = [
                'labels' => ['No data available'],
                'datasets' => [
                    [
                        'label' => 'Downtime Hours',
                        'data' => [0],
                        'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                        'borderColor' => 'rgba(54, 162, 235, 1)',
                        'borderWidth' => 1
                    ]
                ]
            ];
        }
    }

    protected function getDowntimeTypesData($equipmentIds, $startDate, $endDate)
    {
        try {
            Log::info('DowntimeImpact: Iniciando getDowntimeTypesData');
            
            // Verificar quais campos usar para filtragem e cálculos
            $dateField = 'created_at';
            $durationField = '';
            
            // Determinar o campo de data a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'start_date')) {
                $dateField = 'start_date';
            } else if (Schema::hasColumn('maintenance_correctives', 'date')) {
                $dateField = 'date';
            }
            
            // Determinar o campo de duração a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'duration_hours')) {
                $durationField = 'duration_hours';
            } else if (Schema::hasColumn('maintenance_correctives', 'downtime')) {
                $durationField = 'downtime';
            } else if (Schema::hasColumn('maintenance_correctives', 'hours')) {
                $durationField = 'hours';
            } else {
                // Se não encontrar campo de duração, usar contagem de registros
                $durationField = 'id';
                Log::warning('DowntimeImpact: Nenhum campo de duração encontrado, usando contagem de registros');
            }
            
            // Group downtime by type
            $query = DowntimeRecord::whereIn('equipment_id', $equipmentIds);
            
            // Aplicar filtro de data
            if ($dateField === 'created_at') {
                $query->whereBetween($dateField, [$startDate . ' 00:00:00', $endDate . ' 23:59:59']);
            } else {
                $query->whereBetween($dateField, [$startDate, $endDate]);
            }

            // Verificar se a coluna 'type' existe
            $hasTypeColumn = Schema::hasColumn('maintenance_correctives', 'type');
            
            if (!$hasTypeColumn) {
                Log::warning('DowntimeImpact: Coluna "type" não encontrada na tabela maintenance_correctives');
                // Criar dados simulados para gráfico de tipos
                $this->downtimeTypesData = [
                    'labels' => ['Unplanned', 'Planned', 'Operational'],
                    'datasets' => [
                        [
                            'data' => [60, 30, 10],
                            'backgroundColor' => [
                                'rgba(255, 99, 132, 0.8)',
                                'rgba(54, 162, 235, 0.8)',
                                'rgba(255, 205, 86, 0.8)'
                            ],
                            'borderColor' => [
                                'rgba(255, 99, 132, 1)',
                                'rgba(54, 162, 235, 1)',
                                'rgba(255, 205, 86, 1)'
                            ],
                            'borderWidth' => 1
                        ]
                    ]
                ];
                
                Log::info('DowntimeImpact: Usando dados simulados para gráfico de tipos');
                return;
            }
            
            // Aplicar filtro de tipo, se fornecido e se a coluna existir
            if ($this->downtimeType !== 'all') {
                $typeValue = $this->downtimeType;
                if (strtolower($this->downtimeType) === 'planned') {
                    $typeValue = 'Planned';
                } else if (strtolower($this->downtimeType) === 'unplanned') {
                    $typeValue = 'Unplanned';
                } else if (strtolower($this->downtimeType) === 'operational') {
                    $typeValue = 'Operational';
                }
                
                $query->where('type', $typeValue);
            }
            
            // Criar a consulta SQL adequada
            if ($durationField === 'id') {
                // Se não encontrou campo de duração, usa contagem
                $downtimeByType = $query->select('type', DB::raw('COUNT(id) as total_downtime'))
                    ->groupBy('type')
                    ->orderByDesc('total_downtime')
                    ->get();
            } else {
                // Se encontrou campo de duração, usa soma
                $downtimeByType = $query->select('type', DB::raw('SUM(' . $durationField . ') as total_downtime'))
                    ->groupBy('type')
                    ->orderByDesc('total_downtime')
                    ->get();
            }
            
            Log::info('DowntimeImpact: Consulta por tipo executada', [
                'count' => count($downtimeByType)
            ]);

            // Extrair labels e dados
            $labels = $downtimeByType->pluck('type')->toArray();
            $data = $downtimeByType->pluck('total_downtime')->toArray();

            // Create color array
            $backgroundColors = [
                'Planned' => 'rgba(54, 162, 235, 0.8)',
                'Unplanned' => 'rgba(255, 99, 132, 0.8)',
                'Operational' => 'rgba(255, 205, 86, 0.8)',
                'Other' => 'rgba(75, 192, 192, 0.8)'
            ];

            $colors = array_map(function($type) use ($backgroundColors) {
                return $backgroundColors[$type] ?? 'rgba(201, 203, 207, 0.8)';
            }, $labels);

            $this->downtimeTypesData = [
                'labels' => $labels,
                'datasets' => [
                    [
                        'data' => $data,
                        'backgroundColor' => $colors,
                        'borderColor' => array_map(function($color) {
                            return str_replace('0.8', '1', $color);
                        }, $colors),
                        'borderWidth' => 1
                    ]
                ]
            ];

            // Set default data if empty
            if (empty($labels)) {
                Log::info('DowntimeImpact: Nenhum dado de tipo encontrado, usando valores padrão');
                $this->downtimeTypesData = [
                    'labels' => ['No data available'],
                    'datasets' => [
                        [
                            'data' => [0],
                            'backgroundColor' => ['rgba(201, 203, 207, 0.8)'],
                            'borderColor' => ['rgba(201, 203, 207, 1)'],
                            'borderWidth' => 1
                        ]
                    ]
                ];
            }
            
            Log::info('DowntimeImpact: getDowntimeTypesData concluído com sucesso');
            
        } catch (\Exception $e) {
            Log::error('Erro em getDowntimeTypesData', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Em caso de erro, usar valores padrão
            $this->downtimeTypesData = [
                'labels' => ['No data available'],
                'datasets' => [
                    [
                        'data' => [0],
                        'backgroundColor' => ['rgba(201, 203, 207, 0.8)'],
                        'borderColor' => ['rgba(201, 203, 207, 1)'],
                        'borderWidth' => 1
                    ]
                ]
            ];
        }
    }

    protected function getDowntimeCausesData($equipmentIds, $startDate, $endDate)
    {
        try {
            Log::info('DowntimeImpact: Iniciando getDowntimeCausesData');
            
            // Verificar quais campos usar para filtragem e cálculos
            $dateField = 'created_at';
            $durationField = '';
            $causeField = '';
            
            // Determinar o campo de data a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'start_date')) {
                $dateField = 'start_date';
            } else if (Schema::hasColumn('maintenance_correctives', 'date')) {
                $dateField = 'date';
            }
            
            // Determinar o campo de duração a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'duration_hours')) {
                $durationField = 'duration_hours';
            } else if (Schema::hasColumn('maintenance_correctives', 'downtime')) {
                $durationField = 'downtime';
            } else if (Schema::hasColumn('maintenance_correctives', 'hours')) {
                $durationField = 'hours';
            } else {
                // Se não encontrar campo de duração, usar contagem de registros
                $durationField = 'id';
                Log::warning('DowntimeImpact: Nenhum campo de duração encontrado, usando contagem de registros');
            }
            
            // Determinar o campo de causa a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'cause_description')) {
                $causeField = 'cause_description';
            } else if (Schema::hasColumn('maintenance_correctives', 'cause')) {
                $causeField = 'cause';
            } else if (Schema::hasColumn('maintenance_correctives', 'fault_description')) {
                $causeField = 'fault_description';
            } else if (Schema::hasColumn('maintenance_correctives', 'description')) {
                $causeField = 'description';
            } else {
                // Se não encontrar campo de causa, usar valores padrão
                Log::warning('DowntimeImpact: Nenhum campo de causa encontrado na tabela');
                
                // Criar dados simulados para o gráfico de causas
                $this->downtimeCausesData = [
                    'labels' => ['Equipment Failure', 'Operator Error', 'Material Issue', 'Setup Problem', 'Power Outage'],
                    'datasets' => [
                        [
                            'data' => [35, 25, 20, 15, 5],
                            'backgroundColor' => [
                                'rgba(255, 99, 132, 0.8)',
                                'rgba(54, 162, 235, 0.8)',
                                'rgba(255, 205, 86, 0.8)',
                                'rgba(75, 192, 192, 0.8)',
                                'rgba(153, 102, 255, 0.8)'
                            ],
                            'borderColor' => [
                                'rgba(255, 99, 132, 1)',
                                'rgba(54, 162, 235, 1)',
                                'rgba(255, 205, 86, 1)',
                                'rgba(75, 192, 192, 1)',
                                'rgba(153, 102, 255, 1)'
                            ],
                            'borderWidth' => 1
                        ]
                    ]
                ];
                
                Log::info('DowntimeImpact: Usando dados simulados para gráfico de causas');
                return;
            }
            
            // Group downtime by cause
            $query = DowntimeRecord::whereIn('equipment_id', $equipmentIds);
            
            // Aplicar filtro de data
            if ($dateField === 'created_at') {
                $query->whereBetween($dateField, [$startDate . ' 00:00:00', $endDate . ' 23:59:59']);
            } else {
                $query->whereBetween($dateField, [$startDate, $endDate]);
            }

            // Verificar se a coluna 'type' existe e aplicar filtro se necessário
            $hasTypeColumn = Schema::hasColumn('maintenance_correctives', 'type');
            
            if ($hasTypeColumn && $this->downtimeType !== 'all') {
                $typeValue = $this->downtimeType;
                if (strtolower($this->downtimeType) === 'planned') {
                    $typeValue = 'Planned';
                } else if (strtolower($this->downtimeType) === 'unplanned') {
                    $typeValue = 'Unplanned';
                } else if (strtolower($this->downtimeType) === 'operational') {
                    $typeValue = 'Operational';
                }
                
                $query->where('type', $typeValue);
            }
            
            // Criar a consulta SQL adequada
            if ($durationField === 'id') {
                // Se não encontrou campo de duração, usa contagem
                $downtimeByCause = $query->select($causeField, DB::raw('COUNT(id) as total_downtime'))
                    ->whereNotNull($causeField)
                    ->where($causeField, '!=', '')
                    ->groupBy($causeField)
                    ->orderByDesc('total_downtime')
                    ->limit(5)
                    ->get();
            } else {
                // Se encontrou campo de duração, usa soma
                $downtimeByCause = $query->select($causeField, DB::raw('SUM(' . $durationField . ') as total_downtime'))
                    ->whereNotNull($causeField)
                    ->where($causeField, '!=', '')
                    ->groupBy($causeField)
                    ->orderByDesc('total_downtime')
                    ->limit(5)
                    ->get();
            }
            
            Log::info('DowntimeImpact: Consulta por causa executada', [
                'count' => count($downtimeByCause)
            ]);

            // Extrair labels e dados
            $labels = $downtimeByCause->pluck($causeField)->toArray();
            $data = $downtimeByCause->pluck('total_downtime')->toArray();

            // Create colors array
            $colors = [
                'rgba(255, 99, 132, 0.8)',
                'rgba(54, 162, 235, 0.8)',
                'rgba(255, 205, 86, 0.8)',
                'rgba(75, 192, 192, 0.8)',
                'rgba(153, 102, 255, 0.8)'
            ];
            
            // Garantir que há cores suficientes
            while (count($colors) < count($labels)) {
                $colors[] = 'rgba(201, 203, 207, 0.8)';
            }

            $this->downtimeCausesData = [
                'labels' => $labels,
                'datasets' => [
                    [
                        'data' => $data,
                        'backgroundColor' => array_slice($colors, 0, count($labels)),
                        'borderColor' => array_map(function($color) {
                            return str_replace('0.8', '1', $color);
                        }, array_slice($colors, 0, count($labels))),
                        'borderWidth' => 1
                    ]
                ]
            ];

            // Set default data if empty
            if (empty($labels)) {
                Log::info('DowntimeImpact: Nenhum dado de causa encontrado, usando valores padrão');
                $this->downtimeCausesData = [
                    'labels' => ['No data available'],
                    'datasets' => [
                        [
                            'data' => [0],
                            'backgroundColor' => ['rgba(201, 203, 207, 0.8)'],
                            'borderColor' => ['rgba(201, 203, 207, 1)'],
                            'borderWidth' => 1
                        ]
                    ]
                ];
            }
            
            Log::info('DowntimeImpact: getDowntimeCausesData concluído com sucesso');
            
        } catch (\Exception $e) {
            Log::error('Erro em getDowntimeCausesData', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Em caso de erro, usar valores padrão
            $this->downtimeCausesData = [
                'labels' => ['Error retrieving data'],
                'datasets' => [
                    [
                        'data' => [0],
                        'backgroundColor' => ['rgba(201, 203, 207, 0.8)'],
                        'borderColor' => ['rgba(201, 203, 207, 1)'],
                        'borderWidth' => 1
                    ]
                ]
            ];
            }
            
            // Generate default dates
            $currentDate = $startCarbon->copy();
            while ($currentDate->lte($endCarbon)) {
                $defaultLabels[] = $currentDate->format($dateFormatLabel);
                if ($grouping === 'daily') {
                    $currentDate->addDay();
                } elseif ($grouping === 'weekly') {
                    $currentDate->addWeek();
                } else {
                    $currentDate->addMonth();
                }
            }
            
            $this->downtimeTrendData = [
                'labels' => $defaultLabels,
                'datasets' => [
                    [
                        'label' => 'Planned',
                        'data' => array_fill(0, count($defaultLabels), 0),
                        'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                        'borderColor' => 'rgba(54, 162, 235, 1)',
                        'borderWidth' => 1
                    ],
                    [
                        'label' => 'Unplanned',
                        'data' => array_fill(0, count($defaultLabels), 0),
                        'backgroundColor' => 'rgba(255, 99, 132, 0.8)',
                        'borderColor' => 'rgba(255, 99, 132, 1)',
                        'borderWidth' => 1
                    ],
                    [
                        'label' => 'Operational',
                        'data' => array_fill(0, count($defaultLabels), 0),
                        'backgroundColor' => 'rgba(255, 205, 86, 0.8)',
                        'borderColor' => 'rgba(255, 205, 86, 1)',
                        'borderWidth' => 1
                    ]
                ]
            ];
        }
    }

    protected function getFinancialImpactData($equipmentIds, $startDate, $endDate)
    {
        try {
            Log::info('DowntimeImpact: Iniciando getFinancialImpactData');
            
            // Verificar quais campos usar para filtragem e cálculos
            $dateField = 'created_at';
            $financialField = '';
            
            // Determinar o campo de data a ser usado
            if (Schema::hasColumn('maintenance_correctives', 'start_date')) {
                $dateField = 'start_date';
            } else if (Schema::hasColumn('maintenance_correctives', 'date')) {
                $dateField = 'date';
            }
            
            // Determinar o campo de impacto financeiro a ser usado
            $hasFinancialField = false;
            if (Schema::hasColumn('maintenance_correctives', 'financial_impact')) {
                $financialField = 'financial_impact';
                $hasFinancialField = true;
            } else if (Schema::hasColumn('maintenance_correctives', 'cost')) {
                $financialField = 'cost';
                $hasFinancialField = true;
            } else if (Schema::hasColumn('maintenance_correctives', 'cost_estimate')) {
                $financialField = 'cost_estimate';
                $hasFinancialField = true;
            }
            
            // Se não encontrar campo de impacto financeiro, usar dados simulados
            if (!$hasFinancialField) {
                Log::warning('DowntimeImpact: Nenhum campo de impacto financeiro encontrado');
                
                // Criar dados simulados para o gráfico de impacto financeiro
                $this->financialImpactData = [
                    'labels' => ['Production', 'Maintenance', 'Quality Control', 'Logistics', 'Assembly'],
                    'datasets' => [
                        [
                            'label' => 'Planned',
                            'data' => [1500, 800, 400, 300, 200],
                            'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                            'borderColor' => 'rgba(54, 162, 235, 1)',
                            'borderWidth' => 1
                        ],
                        [
                            'label' => 'Unplanned',
                            'data' => [2500, 1200, 750, 600, 350],
                            'backgroundColor' => 'rgba(255, 99, 132, 0.8)',
                            'borderColor' => 'rgba(255, 99, 132, 1)',
                            'borderWidth' => 1
                        ],
                        [
                            'label' => 'Operational',
                            'data' => [700, 600, 300, 200, 150],
                            'backgroundColor' => 'rgba(255, 205, 86, 0.8)',
                            'borderColor' => 'rgba(255, 205, 86, 1)',
                            'borderWidth' => 1
                        ]
                    ]
                ];
                
                Log::info('DowntimeImpact: Usando dados simulados para gráfico de impacto financeiro');
                return;
            }
            
            // Preparar consulta
            $query = DowntimeRecord::whereIn('equipment_id', $equipmentIds);
            
            // Aplicar filtro de data
            if ($dateField === 'created_at') {
                $query->whereBetween($dateField, [$startDate . ' 00:00:00', $endDate . ' 23:59:59']);
            } else {
                $query->whereBetween($dateField, [$startDate, $endDate]);
            }
    
            // Verificar se a coluna 'type' existe e aplicar filtro se necessário
            $hasTypeColumn = Schema::hasColumn('maintenance_correctives', 'type');
            
            if ($hasTypeColumn && $this->downtimeType !== 'all') {
                $typeValue = $this->downtimeType;
                if (strtolower($this->downtimeType) === 'planned') {
                    $typeValue = 'Planned';
                } else if (strtolower($this->downtimeType) === 'unplanned') {
                    $typeValue = 'Unplanned';
                } else if (strtolower($this->downtimeType) === 'operational') {
                    $typeValue = 'Operational';
                }
                
                $query->where('type', $typeValue);
            }
    
            $records = $query->with('equipment.area')->get();
            
            Log::info('DowntimeImpact: Registros obtidos para impacto financeiro', [
                'count' => count($records)
            ]);
    
            // Group by area
            $areaData = [];
            foreach ($records as $record) {
                // Obter nome da área, com fallback para 'Unknown Area' se não estiver definido
                $areaName = $record->equipment->area->name ?? 'Unknown Area';
                
                // Inicializar dados da área se ainda não existir
                if (!isset($areaData[$areaName])) {
                    $areaData[$areaName] = [
                        'financial_impact' => 0,
                        'planned' => 0,
                        'unplanned' => 0,
                        'operational' => 0,
                        'other' => 0  // Categoria para tipos desconhecidos
                    ];
                }
                
                // Obter valor do impacto financeiro
                $impact = $record->$financialField ?? 0;
                
                // Adicionar ao total da área
                $areaData[$areaName]['financial_impact'] += $impact;
                
                // Classificar por tipo se a coluna existir
                if ($hasTypeColumn) {
                    $type = $record->type ?? 'Other';
                    
                    if ($type === 'Planned') {
                        $areaData[$areaName]['planned'] += $impact;
                    } elseif ($type === 'Unplanned') {
                        $areaData[$areaName]['unplanned'] += $impact;
                    } elseif ($type === 'Operational') {
                        $areaData[$areaName]['operational'] += $impact;
                    } else {
                        $areaData[$areaName]['other'] += $impact;
                    }
                } else {
                    // Se não há coluna de tipo, considerar tudo como não planejado (unplanned)
                    $areaData[$areaName]['unplanned'] += $impact;
                }
            }
    
            // Sort by total financial impact
            uasort($areaData, function($a, $b) {
                return $b['financial_impact'] <=> $a['financial_impact'];
            });
            
            // Limitar a 5 principais áreas se houver muitas
            if (count($areaData) > 5) {
                $areaData = array_slice($areaData, 0, 5, true);
            }
            
            Log::info('DowntimeImpact: Áreas agrupadas', [
                'areasCount' => count($areaData)
            ]);
    
            // Prepare chart data
            $labels = array_keys($areaData);
    
            $datasets = [
                [
                    'label' => 'Planned',
                    'data' => array_map(function($item) { return round($item['planned'], 2); }, $areaData),
                    'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                    'borderColor' => 'rgba(54, 162, 235, 1)',
                    'borderWidth' => 1
                ],
                [
                    'label' => 'Unplanned',
                    'data' => array_map(function($item) { return round($item['unplanned'], 2); }, $areaData),
                    'backgroundColor' => 'rgba(255, 99, 132, 0.8)',
                    'borderColor' => 'rgba(255, 99, 132, 1)',
                    'borderWidth' => 1
                ],
                [
                    'label' => 'Operational',
                    'data' => array_map(function($item) { return round($item['operational'], 2); }, $areaData),
                    'backgroundColor' => 'rgba(255, 205, 86, 0.8)',
                    'borderColor' => 'rgba(255, 205, 86, 1)',
                    'borderWidth' => 1
                ]
            ];
            
            // Adicionar "Other" se houver dados nessa categoria
            $otherData = array_map(function($item) { return round($item['other'], 2); }, $areaData);
            if (array_sum($otherData) > 0) {
                $datasets[] = [
                    'label' => 'Other',
                    'data' => $otherData,
                    'backgroundColor' => 'rgba(75, 192, 192, 0.8)',
                    'borderColor' => 'rgba(75, 192, 192, 1)',
                    'borderWidth' => 1
                ];
            }
    
            $this->financialImpactData = [
                'labels' => $labels,
                'datasets' => $datasets
            ];
    
            // Set default data if empty
            if (empty($labels)) {
                Log::info('DowntimeImpact: Nenhum dado de impacto financeiro encontrado, usando valores padrão');
                $this->financialImpactData = [
                    'labels' => ['No data available'],
                    'datasets' => [
                        [
                            'label' => 'No Data',
                            'data' => [0],
                            'backgroundColor' => 'rgba(201, 203, 207, 0.8)',
                            'borderColor' => 'rgba(201, 203, 207, 1)',
                            'borderWidth' => 1
                        ]
                    ]
                ];
            }
            
            Log::info('DowntimeImpact: getFinancialImpactData concluído com sucesso');
            
        } catch (\Exception $e) {
            Log::error('Erro em getFinancialImpactData', [
                'error' => $e->getMessage(),
                'line' => $e->getLine(),
                'file' => $e->getFile(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Em caso de erro, usar valores padrão
            $this->financialImpactData = [
                'labels' => ['Error retrieving data'],
                'datasets' => [
                    [
                        'label' => 'Error',
                        'data' => [0],
                        'backgroundColor' => 'rgba(201, 203, 207, 0.8)',
                        'borderColor' => 'rgba(201, 203, 207, 1)',
                        'borderWidth' => 1
                    ]
                ]
            ];
        }
    }

    protected function generateRecommendations()
    {
        // Generate improvement recommendations based on downtime data
        $this->recommendations = [];

        try {
            // Check if we have downtime records to analyze
            if (empty($this->downtimeRecords)) {
                return;
            }

            // 1. Most frequent failure equipment - recommend preventive maintenance
            $equipmentIssues = collect($this->downtimeRecords)
                ->where('type', 'Unplanned')
                ->groupBy('equipment')
                ->map(function($group) {
                    return [
                        'equipment' => $group->first()['equipment'],
                        'count' => $group->count(),
                        'total_downtime' => $group->sum('duration'),
                        'financial_impact' => $group->sum('financial_impact'),
                        'most_common_reason' => $group->groupBy('reason')
                            ->map(function($reasonGroup) { return $reasonGroup->count(); })
                            ->sortDesc()
                            ->keys()
                            ->first()
                    ];
                })
                ->sortByDesc('count')
                ->take(3)
                ->values()
                ->toArray();

            foreach ($equipmentIssues as $issue) {
                if ($issue['count'] >= 2) {
                    $this->recommendations[] = [
                        'title' => 'Increase Preventive Maintenance for ' . $issue['equipment'],
                        'target' => $issue['equipment'],
                        'description' => 'This equipment has experienced ' . $issue['count'] . ' unplanned failures, with ' .
                            number_format($issue['total_downtime'], 1) . ' hours of downtime and $' .
                            number_format($issue['financial_impact']) . ' financial impact. Most common reason: ' .
                            ($issue['most_common_reason'] ?? 'Various issues'),
                        'priority' => $issue['financial_impact'] > 5000 ? 'High' : ($issue['financial_impact'] > 2000 ? 'Medium' : 'Low'),
                        'potential_hours_saved' => round($issue['total_downtime'] * 0.7, 1),
                        'estimated_roi' => round($issue['financial_impact'] * 0.6),
                        'implementation_steps' => [
                            'Perform complete inspection of ' . $issue['equipment'],
                            'Increase PM frequency by 50%',
                            'Focus on ' . ($issue['most_common_reason'] ?? 'critical components'),
                            'Train operators on early warning signs',
                            'Implement condition monitoring if applicable'
                        ]
                    ];
                }
            }

            // 2. Check for areas with high operational downtime - process improvements
            $areaOperationalIssues = collect($this->downtimeRecords)
                ->where('type', 'Operational')
                ->groupBy('area')
                ->map(function($group) {
                    return [
                        'area' => $group->first()['area'],
                        'total_downtime' => $group->sum('duration'),
                        'financial_impact' => $group->sum('financial_impact'),
                        'most_common_reason' => $group->groupBy('reason')
                            ->map(function($reasonGroup) { return $reasonGroup->count(); })
                            ->sortDesc()
                            ->keys()
                            ->first()
                    ];
                })
                ->sortByDesc('total_downtime')
                ->take(2)
                ->values()
                ->toArray();

            foreach ($areaOperationalIssues as $issue) {
                if ($issue['total_downtime'] >= 8) {
                    $this->recommendations[] = [
                        'title' => 'Process Optimization for ' . $issue['area'],
                        'target' => $issue['area'] . ' Area',
                        'description' => 'This area has ' . number_format($issue['total_downtime'], 1) .
                            ' hours of operational downtime with $' . number_format($issue['financial_impact']) .
                            ' financial impact. Most common reason: ' . ($issue['most_common_reason'] ?? 'Various issues'),
                        'priority' => $issue['financial_impact'] > 10000 ? 'High' : ($issue['financial_impact'] > 5000 ? 'Medium' : 'Low'),
                        'potential_hours_saved' => round($issue['total_downtime'] * 0.5, 1),
                        'estimated_roi' => round($issue['financial_impact'] * 0.4),
                        'implementation_steps' => [
                            'Conduct workflow analysis in ' . $issue['area'],
                            'Identify bottlenecks related to ' . ($issue['most_common_reason'] ?? 'operational processes'),
                            'Implement standard work procedures',
                            'Train staff on optimized processes',
                            'Monitor and adjust based on performance metrics'
                        ]
                    ];
                }
            }

            // 3. Identify planned maintenance optimization opportunities
            $longPlannedDowntime = collect($this->downtimeRecords)
                ->where('type', 'Planned')
                ->filter(function($record) {
                    return $record['duration'] > 4; // Focus on longer planned maintenance
                })
                ->groupBy('equipment')
                ->map(function($group) {
                    return [
                        'equipment' => $group->first()['equipment'],
                        'area' => $group->first()['area'],
                        'total_downtime' => $group->sum('duration'),
                        'average_duration' => $group->avg('duration'),
                        'financial_impact' => $group->sum('financial_impact'),
                        'count' => $group->count()
                    ];
                })
                ->sortByDesc('total_downtime')
                ->take(2)
                ->values()
                ->toArray();

            foreach ($longPlannedDowntime as $issue) {
                $this->recommendations[] = [
                    'title' => 'Optimize Planned Maintenance for ' . $issue['equipment'],
                    'target' => $issue['equipment'],
                    'description' => 'This equipment requires ' . number_format($issue['total_downtime'], 1) .
                        ' hours of planned maintenance with $' . number_format($issue['financial_impact']) .
                        ' impact. Average duration: ' . number_format($issue['average_duration'], 1) . ' hours per maintenance.',
                    'priority' => $issue['average_duration'] > 8 ? 'High' : ($issue['average_duration'] > 4 ? 'Medium' : 'Low'),
                    'potential_hours_saved' => round($issue['total_downtime'] * 0.3, 1),
                    'estimated_roi' => round($issue['financial_impact'] * 0.25),
                    'implementation_steps' => [
                        'Review maintenance procedures for ' . $issue['equipment'],
                        'Identify tasks that can be performed in parallel',
                        'Pre-stage parts and tools before maintenance',
                        'Train maintenance technicians on optimized procedures',
                        'Consider predictive maintenance technologies'
                    ]
                ];
            }

            // 4. Generic recommendation if none of the above apply
            if (count($this->recommendations) == 0 && $this->totalDowntime > 0) {
                $this->recommendations[] = [
                    'title' => 'Implement Downtime Tracking System',
                    'target' => 'All Equipment',
                    'description' => 'Implement a detailed downtime tracking system to better categorize and analyze downtime causes.',
                    'priority' => 'Medium',
                    'potential_hours_saved' => round($this->totalDowntime * 0.15, 1),
                    'estimated_roi' => round($this->financialImpact * 0.1),
                    'implementation_steps' => [
                        'Define downtime categories and reasons',
                        'Train operators on proper downtime reporting',
                        'Implement automated downtime tracking where possible',
                        'Create regular review process for downtime data',
                        'Establish continuous improvement team to address findings'
                    ]
                ];
            }

        } catch (\Exception $e) {
            Log::error('Error generating downtime recommendations: ' . $e->getMessage());
        }
    }

    protected function setDefaultChartData()
    {
        // Set default chart data if there's an error loading from database
        $this->downtimeByEquipmentData = [
            'labels' => ['No data available'],
            'datasets' => [
                [
                    'label' => 'Downtime Hours',
                    'data' => [0],
                    'backgroundColor' => 'rgba(54, 162, 235, 0.8)',
                    'borderColor' => 'rgba(54, 162, 235, 1)',
                    'borderWidth' => 1
                ]
            ]
        ];

        $this->downtimeTypesData = [
            'labels' => ['No data available'],
            'datasets' => [
                [
                    'data' => [0],
                    'backgroundColor' => ['rgba(201, 203, 207, 0.8)'],
                    'borderColor' => ['rgba(201, 203, 207, 1)'],
                    'borderWidth' => 1
                ]
            ]
        ];

        $this->downtimeTrendData = [
            'labels' => ['No data available'],
            'datasets' => [
                [
                    'label' => 'No Data',
                    'data' => [0],
                    'backgroundColor' => 'rgba(201, 203, 207, 0.8)',
                    'borderColor' => 'rgba(201, 203, 207, 1)',
                    'borderWidth' => 2,
                    'tension' => 0.4
                ]
            ]
        ];

        $this->financialImpactData = [
            'labels' => ['No data available'],
            'datasets' => [
                [
                    'label' => 'No Data',
                    'data' => [0],
                    'backgroundColor' => 'rgba(201, 203, 207, 0.8)',
                    'borderColor' => 'rgba(201, 203, 207, 1)',
                    'borderWidth' => 1
                ]
            ]
        ];

        $this->downtimeRecords = [];
        $this->totalDowntime = 0;
        $this->productionLoss = 0;
        $this->financialImpact = 0;
        $this->availabilityRate = 100;
        $this->mostCriticalEquipment = 'None';
        $this->mostCriticalDowntime = 0;
        $this->recommendations = [];
    }

    public function render()
    {
        try {
            Log::info('DowntimeImpact render: Preparing view with data', [
                'totalDowntime' => $this->totalDowntime,
                'recordCount' => count($this->downtimeRecords),
                'chartDataAvailable' => !empty($this->downtimeByEquipmentData['labels']) && $this->downtimeByEquipmentData['labels'][0] !== 'No data available'
            ]);
            
            // Ensure chart data is properly initialized
            if (empty($this->downtimeByEquipmentData)) {
                $this->setDefaultChartData();
            }
            
            return view('livewire.reports.downtime-impact', [
                'areas' => $this->areas,
                'lines' => $this->lines,
                'downtimeRecords' => $this->downtimeRecords,
                'totalDowntime' => $this->totalDowntime,
                'productionLoss' => $this->productionLoss,
                'financialImpact' => $this->financialImpact,
                'availabilityRate' => $this->availabilityRate,
                'mostCriticalEquipment' => $this->mostCriticalEquipment,
                'mostCriticalDowntime' => $this->mostCriticalDowntime,
                'downtimeByEquipmentData' => $this->downtimeByEquipmentData,
                'downtimeTypesData' => $this->downtimeTypesData,
                'downtimeTrendData' => $this->downtimeTrendData,
                'financialImpactData' => $this->financialImpactData,
                'recommendations' => $this->recommendations
            ]);
        } catch (\Exception $e) {
            Log::error('Error in DowntimeImpact render method', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            
            // Ensure we have default data to prevent view errors
            $this->setDefaultChartData();
            
            return view('livewire.reports.downtime-impact', [
                'areas' => $this->areas,
                'lines' => $this->lines,
                'downtimeRecords' => [],
                'totalDowntime' => 0,
                'productionLoss' => 0,
                'financialImpact' => 0,
                'availabilityRate' => 100,
                'mostCriticalEquipment' => 'None',
                'mostCriticalDowntime' => 0,
                'downtimeByEquipmentData' => $this->downtimeByEquipmentData,
                'downtimeTypesData' => $this->downtimeTypesData,
                'downtimeTrendData' => $this->downtimeTrendData,
                'financialImpactData' => $this->financialImpactData,
                'recommendations' => []
            ]);
        }
    }
}
